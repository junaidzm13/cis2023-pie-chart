package com.csg.codeit.data

import ChordDiagram
import PieChart
import com.csg.codeit.model.ChallengeResult
import com.csg.codeit.model.OutputPart2
import com.csg.codeit.model.Part
import com.csg.codeit.service.ResultCheckerService
import com.csg.codeit.solution.AngleCalculator.Companion.defaultMinShare
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.ValueSource
import kotlin.math.abs

class TestCasesProviderTest {
    private val testCasesProvider = TestCasesProvider()

    @ParameterizedTest(name = "Simulation number: {0}")
    @ValueSource(ints = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    fun `getTestCases provides 10 valid test cases for each part`() {
        val testCases = testCasesProvider.getTestCases()
        val testCasesByPart = testCases.groupBy { it.input.part }

        assertThat(testCasesByPart[Part.FIRST]?.size).isEqualTo(10)
        assertThat(testCasesByPart[Part.FIRST]?.sumOf { it.score }).isEqualTo(40)
        assertThat(testCasesByPart[Part.FIRST]?.all { it.input.data.isNotEmpty() && it.input.data.size <= 2000 }).isTrue

        assertThat(testCasesByPart[Part.SECOND]?.size).isEqualTo(10)
        assertThat(testCasesByPart[Part.SECOND]?.sumOf { it.score }).isEqualTo(60)
        assertThat(testCasesByPart[Part.SECOND]?.all { it.input.data.isNotEmpty() && it.input.data.size <= 666 }).isTrue
    }

    @Test
    fun `sample solution can solve the test cases generated by getTestCases`() {
        val testCases = testCasesProvider.getTestCases()
        val checkerService = ResultCheckerService()
        val (part1Solver, part2Solver) = Pair(PieChart(), ChordDiagram())

        val challengeResult = testCases.map { case ->
            val solver = if (case.input.part == Part.FIRST) part1Solver else part2Solver
            val solverResult = solver.calculateCoordinates(case.input.data).toListOfAngles()
            checkerService.check(solverResult, case)
        }.reduce(ChallengeResult::plus)

        assertThat(challengeResult.score).isEqualTo(100)
    }

    @Test
    fun `can create 2-step re-balancing test case for part 1`() {
        val testCase = create2StepReBalancingRandomTCP1(10)

        val instrumentValues = testCase.input.data.map { it.price * it.quantity }
        val totalValue = instrumentValues.sum()
        val initialOutliersCount = instrumentValues.count { it / totalValue < defaultMinShare }

        val resultingAngles = testCase.output.toListOfAngles()
        val totalRebalancedAngles = (0 until resultingAngles.size - 1).reduce { acc: Int, index: Int ->
            val angle = resultingAngles[index + 1] - resultingAngles[index]
            acc + if (abs(angle - defaultMinShare * 2 * Math.PI) < 0.000000001) 1 else 0
        }

        assertThat(resultingAngles.size - 1).isEqualTo(instrumentValues.size)
        assertThat(totalRebalancedAngles).isGreaterThan(initialOutliersCount)
    }

    @Test
    fun `can create 2-step re-balancing test case for part 2`() {
        val testCase = create2StepReBalancingRandomTCP2(10)

        val instrumentValues = testCase.input.data.map { it.price * it.quantity }
        val totalValue = instrumentValues.sum()
        val initialOutliersCount = instrumentValues.count { it / totalValue < defaultMinShare }

        val resultingAngles = (testCase.output as OutputPart2).instruments
        val totalRebalancedAngles = (0 until resultingAngles.size - 1).reduce { acc: Int, index: Int ->
            val angle = resultingAngles[index + 1] - resultingAngles[index]
            acc + if (abs(angle - defaultMinShare * 2 * Math.PI) < 0.000000001) 1 else 0
        }

        assertThat(resultingAngles.size - 1).isEqualTo(instrumentValues.size)
        assertThat(totalRebalancedAngles).isGreaterThan(initialOutliersCount)
    }
}